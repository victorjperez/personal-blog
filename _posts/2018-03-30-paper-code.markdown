---
layout: Page
title:  "Paper Code"
date:   2018-03-30 00:50:34 -0400
author: "Victor Perez"
categories: [creative nonfiction, tech]
image: "cnf.jpg"
---
As I’ve become more and more experienced as a programmer, one thing has abundantly clear: the less time you spend writing code, the better. Much like writing a book, if you just hop on your computer and start typing, you’ll eventually find yourself tangled in your own work, making something that is more or less impossible to work with. If you chose to continue working on the same poor foundation, more and more time will be spent dedicated to solving problems that you caused, that could have easily been prevent. It is because of this that the majority of my time is spent carefully deciphering what the problem is and planning out how I will solve it.

As an example, a factorial program is one of the earliest programming puzzles you may encounter as a rookie programmer. The first step is understanding what a factorial is and how it behaves. This is the point where I whip out the programmer’s primary tools: pen and paper. Looking at the behavior of a factorial, I would trace it by hand on paper. 3 factorial is 1 x 2 x 3, 5 factorial is 1 x 2 x 3 x 4 x 5, and so on. It’s important to recognize the pattern in this situation: every number is multiplied by every factor before it.

Now that I know what a factorial is and how it operates, it’s still not time to leave the paper. The next step is the programmers second best friend: charts! I love charts, can’t get enough of them. It’s easy to get lost when following how a program executes, and charts make things clear. First I label it with the function name factorial(*number*) (a function is basically a formula that you write yourself). The *number* value can be any number, so the program I write must be able to work with anything. First I look at cases where the program must fail. You can’t take the factorial of a negative number, or a number that doesn’t exist, so I mark that in a box in the top right. After a quick study of my previous findings, I recognize that I should use a special technique that is common for repeatable processes called recursion. Since taking the factorial of any number requires taking the factorial of the previous number before it, I can chain factorial operations based on what number I take in. It’s a little difficult to comprehend at first, but as an example, take 3 factorial and 2 factorial. 3 factorial is 3 x 2 x 1 and 2 factorial is 2 x 1. Another way to calculate 3 factorial is to multiply 2 factorial by 3. Using this logical, every factorial is essential *number* x factorial(*number*) until *number* equals 1. If you can’t exactly follow that, don’t think too hard about it. It’s harder to parse that logic in your mind, which is why a chart is essential.

Finally, it’s time to hop on the computer. This should be the easy part. Using whatever language I choose, I take all my notes and write the program. If something goes wrong, I can draw out each step on paper to help understand where I’ve made a mistake. If the solution is completely wrong, I hop off the computer again, and go back to the drawing board. Staring at the screen trying to solve a problem is usually very tiring, and fairly ineffective when it comes to more conceptual problems. Finally, once it’s all said and done, I calculate the factorials of various numbers on paper using a calculator, and input those into the factorial function. If everything checks out, the program is finished.
